import { Injectable, Logger, ForbiddenException } from "@nestjs/common";
import { CampaignRepository } from "../repositories/campaign.repository";
import { QueueService } from "../../../core/job/queue.service";
import { 
  Campaign, 
  CampaignStatus, 
} from "../../../common/types/database/entity.types";
import { 
  CreateCampaignData, 
} from "../types/campaign.repo-types";
import { 
  CreateCampaignInput,
  CampaignProgress,
  CampaignWithTasks,
} from "../types/campaign.service-types";
import { JobStatus } from "../../../common/types/job/queue.types";

@Injectable()
export class CampaignService {
  private readonly logger = new Logger(CampaignService.name);

  constructor(
    private readonly campaignRepository: CampaignRepository,
    private readonly queueService: QueueService,
  ) {}

  // ==================== Create and launch a campaign ====================

  /**
   * Create and launch a Campaign
   * Process: Create Campaign record → Place in queue → Return (without waiting for completion)
   * 
   * No Tasks are created at this stage; Tasks are dynamically generated by the Agent during execution
   */
  async createAndStartCampaign(input: CreateCampaignInput): Promise<Campaign> {
    this.logger.log(`Creating campaign for user: ${input.userId}`);

    // Create Campaign record (status: ACTIVE)
    const campaignData: CreateCampaignData = {
      userId: input.userId,
      name: input.name,
      description: input.description,
      status: CampaignStatus.ACTIVE,
      input: {
        userPrompt: input.userPrompt,
        userContext: input.agentInvokeOptions?.userContext,
      },
    };

    const campaign = await this.campaignRepository.createCampaign(campaignData);
    this.logger.log(`Campaign created with ID: ${campaign.id}`);

    // Put it into queue: async execution, non-blocking
    // Pass metadata to agentInvokeOptions for the Processor
    await this.queueService.addCampaignJob(campaign.id, input.userId, {
      priority: input.priority,
      delay: input.delay,
      metadata: {
        agentInvokeOptions: input.agentInvokeOptions,
      },
    });
    this.logger.log(`Campaign ${campaign.id} queued for execution`);

    // Return immediately campaign（do not wait for completion）
    return campaign;
  }

  // ==================== Query and progress ====================

  /**
   * Get the single Campaign
   */
  public async getCampaignById(
    campaignId: string,
    userId: string,
    options?: { includeTasks?: boolean, includeUser?: boolean }
  ): Promise<Campaign> {
    const campaign = await this.campaignRepository.findCampaignById(
      campaignId,
      options?.includeTasks ?? false,
      options?.includeUser ?? false,
    );

    // Only access to user's owned Campaign
    if (campaign.userId !== userId) {
      throw new ForbiddenException('You do not have permission to access this campaign');
    }
    return campaign;
  }

  private getProgressMessage(
    jobStatus: JobStatus | null
  ): string {
    if (!jobStatus) {
      return 'Campaign is pending';
    }

    switch (jobStatus.state) {
      case 'waiting':
        return 'Waiting in queue';
      case 'active':
        return `Processing... ${jobStatus.progress}%`;
      case 'completed':
        return 'Completed';
      case 'failed':
        return `Failed: ${jobStatus.failedReason || 'Unknown error'}`;
      default:
        return 'Unknown status';
    }
  }

  async getCampaignProgress(
    campaignId: string,
    userId: string
  ): Promise<CampaignProgress> {
    // Get Campaign
    const campaign = await this.getCampaignById(campaignId, userId, { 
      includeTasks: true 
    });

    // If the database already shows it as completed or archived, return it
    if (campaign.status === CampaignStatus.ARCHIVED) {
      return {
        campaignId,
        status: campaign.status,
        message: "Campaign completed",
        taskStats: {
          total: campaign.tasks?.length || 0,
          completed: campaign.tasks?.filter(t => t.status === 'COMPLETED').length || 0,
          failed: campaign.tasks?.filter(t => t.status === 'FAILED').length || 0,
        }
      };
    }

    // Retrieve the status of a job in the queue
    const jobStatus = await this.queueService.getJobStatus(`campaign-${campaignId}`);

    // Build progress information
    const progress: CampaignProgress = {
      campaignId,
      status: campaign.status,
      message: this.getProgressMessage(jobStatus),
    };
    return progress;
  }

  /**
   * Retrieve completed Campaigns (including Tasks)
   */
  async getCompletedCampaignWithTasks(
    campaignId: string,
    userId: string
  ): Promise<CampaignWithTasks> {
    const campaign = await this.getCampaignById(campaignId, userId, { 
      includeTasks: true 
    });

    // Only archived ones will have complete results
    if (campaign.status !== CampaignStatus.ARCHIVED) {
      throw new ForbiddenException('Campaign is not yet completed');
    }

    return campaign as CampaignWithTasks;
  }

  // ==================== Manager Operation ====================

  /**
   * Archive Campaign
   */
  async archiveCampaign(campaignId: string, userId: string): Promise<Campaign> {
    await this.getCampaignById(campaignId, userId);

    // Attempt to remove it from the queue (if it is still pending).
    try {
      await this.queueService.removeJob(`campaign-${campaignId}`);
      this.logger.log(`Job removed from queue: ${campaignId}`);
    } catch {
      this.logger.warn(`Job may already be processing or completed: ${campaignId}`);
    }

    // Soft delete（remark as ARCHIVED）
    return this.campaignRepository.softDeleteCampaign(campaignId);
  }

  /**
   * Retry the failed Campaign
   */
  async retryCampaign(campaignId: string, userId: string): Promise<Campaign> {
    const campaign = await this.getCampaignById(campaignId, userId);

    // Only status is ARCHIVED and no results can be retried
    if (campaign.status !== CampaignStatus.ARCHIVED || campaign.result !== null) {
      throw new ForbiddenException('Only failed campaigns can be retried');
    }

    // First of all attempt to retry, if failed, re-enqueue job
    const existingJob = await this.queueService.getJobByCampaignId(campaignId);

    if (existingJob) {
      // Job attempt retry
      await this.queueService.retryJob(campaignId);
    } else {
      // Job not exists，attempt to re-create
      await this.queueService.addCampaignJob(campaignId, userId, {
        metadata: {
          agentInvokeOptions: {
            userContext: campaign.input.userContext,
          },
        },
      });
    }

    // reset the status as ACTIVE
    const updatedCampaign = await this.campaignRepository.updateCampaign(campaignId, {
      status: CampaignStatus.ACTIVE,
    });

    // Re-enqueue
    await this.queueService.retryJob(campaignId);
    this.logger.log(`Campaign ${campaignId} queued for retry`);
    return updatedCampaign;
  }

  /**
   * Permanently delete the Campaign (including all Tasks).
   */
  async deleteCampaign(campaignId: string, userId: string): Promise<Campaign> {
    await this.getCampaignById(campaignId, userId);

    // Remove job from the queue
    try {
      await this.queueService.removeJob(`campaign-${campaignId}`);
    } catch {
      // Ignore errors indicating the queue does not exist
    }

    return this.campaignRepository.deleteCampaignWithTasks(campaignId);
  }

}
