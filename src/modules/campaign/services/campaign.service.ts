import { Injectable, Logger, ForbiddenException } from "@nestjs/common";
import { CampaignRepository } from "../repositories/campaign.repository";
import { QueueService } from "../../../core/job/queue.service";
import { 
  Campaign, 
  CampaignStatus,
  CreateCampaignInput,
  CreateCampaignData,
  ListCampaignsOptions,
  ListTasksOptions,
  ListTasksByCampaignWithOptions,
  PaginatedCampaignsResponse,
  PaginatedTasksResponse,
} from "../types/campaign.types";

@Injectable()
export class CampaignService {
  private readonly logger = new Logger(CampaignService.name);

  constructor(
    private readonly campaignRepository: CampaignRepository,
    private readonly queueService: QueueService,
  ) {}

  // ==================== Create and launch a campaign ====================

  /**
   * Create and launch a Campaign
   * Process: Create Campaign record → Place in queue → Return (without waiting for completion)
   * 
   * No Tasks are created at this stage; Tasks are dynamically generated by the Agent during execution
   */
  public async createAndStartCampaign(input: CreateCampaignInput): Promise<Campaign> {
    this.logger.log(`Creating campaign for user: ${input.userId}`);

    // Create Campaign record (status: ACTIVE)
    const campaignData: CreateCampaignData = {
      userId: input.userId,
      name: input.name,
      description: input.description,
      status: CampaignStatus.ACTIVE,
      input: {
        userPrompt: input.userPrompt,
        userContext: input.agentInvokeOptions?.userContext,
      },
    };

    const campaign = await this.campaignRepository.createCampaign(campaignData);
    this.logger.log(`Campaign created with ID: ${campaign.id}`);

    // Put it into queue: async execution, non-blocking
    // Pass metadata to agentInvokeOptions for the Processor
    await this.queueService.addCampaignJob(campaign.id, input.userId, {
      metadata: {
        agentInvokeOptions: input.agentInvokeOptions,
      },
    });
    this.logger.log(`Campaign ${campaign.id} queued for execution`);

    // Return immediately campaign（do not wait for completion）
    return campaign;
  }

  // ==================== Query and progress ====================

  /**
   * Get the single Campaign by ID
   */
  public async getCampaignById(
    campaignId: string,
    userId: string,
    options?: { includeTasks?: boolean, includeUser?: boolean }
  ): Promise<Campaign> {
    const campaign = await this.campaignRepository.findCampaignById(
      campaignId,
      options?.includeTasks ?? false,
      options?.includeUser ?? false,
    );

    // Only access to user"s owned Campaign
    if (campaign.userId !== userId) {
      this.logger.warn(
        `User ${userId} attempted to access campaign ${campaignId} owned by ${campaign.userId}`
      );
      throw new ForbiddenException("You do not have permission to access this campaign");
    }
    return campaign;
  }

  /**
   * List campaigns with filtering, sorting, and pagination
   */
  public async getCampaignsByOptions(
    userId: string,
    options: Omit<ListCampaignsOptions, "where"> & {
      where?: Omit<ListCampaignsOptions["where"], "userId">;
    } = {}
  ): Promise<PaginatedCampaignsResponse> {
    // Enforce userId filter for security
    const secureOptions: ListCampaignsOptions = {
      ...options,
      where: {
        ...options.where,
        userId, // Always filter by userId
      },
    };

    return this.campaignRepository.findManyCampaignsByOptions(secureOptions);
  }

  /**
   * List tasks for a specific campaign
   */
  public async getTasksByCampaignWithOptions(
    campaignId: string,
    userId: string,
    options: Omit<ListTasksByCampaignWithOptions, "campaignId"> = {}
  ): Promise<PaginatedTasksResponse> {

    // Verify user has access to this campaign (authorization check)
    await this.getCampaignById(campaignId, userId);

    this.logger.log(`Listing tasks for campaign ${campaignId} (user: ${userId})`);

    return this.campaignRepository.findManyTasksByCampaignWithOptions(
      campaignId,
      options
    );
  }

  /**
   * List all tasks across campaigns for the authenticated user
   */
  public async getTasksByUserWithOptions(
    userId: string,
    options: ListTasksOptions = {}
  ): Promise<PaginatedTasksResponse> {
    // Pass userId as first parameter (enforced by repository)
    return this.campaignRepository.findManyTasksByUserWithOptions(userId, options);
  }
  
  // ==================== Manager Operation ====================

  /**
   * Archive Campaign
   */
  public async archiveCampaign(campaignId: string, userId: string): Promise<Campaign> {
    await this.getCampaignById(campaignId, userId);

    // Attempt to remove it from the queue (if it is still pending).
    try {
      await this.queueService.removeJob(`campaign-${campaignId}`);
      this.logger.log(`Job removed from queue: ${campaignId}`);
    } catch {
      this.logger.warn(`Job may already be processing or completed: ${campaignId}`);
    }

    // Soft delete（remark as ARCHIVED）
    return this.campaignRepository.softDeleteCampaign(campaignId);
  }

  /**
   * Retry the failed Campaign
   */
  public async retryCampaign(campaignId: string, userId: string): Promise<Campaign> {
    const campaign = await this.getCampaignById(campaignId, userId);

    // Only status is ARCHIVED and no results can be retried
    if (campaign.status !== CampaignStatus.ARCHIVED || campaign.result !== null) {
      throw new ForbiddenException("Only failed campaigns can be retried");
    }

    // Update status first to avoid queue mismatch
    const updatedCampaign = await this.campaignRepository.updateCampaign(campaignId, {
      status: CampaignStatus.ACTIVE
    });

    try {
      const existingJob = await this.queueService
        .getJobByCampaignId(campaignId)
        .catch(() => null);      
      if (existingJob) {
        const state = await existingJob.getState();

        if (state === "failed") {
          await this.queueService.retryJob(campaignId);
        } else if (state === "completed") {
          this.logger.warn(
            `Job ${existingJob.id} completed but campaign ${campaignId} failed, creating new job`
          );
          await this.queueService.addCampaignJob(campaignId, userId, {
            metadata: {
              agentInvokeOptions: { userContext: campaign.input?.userContext },
            },
          });
        } else {
          // waiting/active/delayed status
          this.logger.warn(
            `Job ${existingJob.id} is in state: ${state}, not retrying`
          );
        }
      } else {
        await this.queueService.addCampaignJob(campaignId, userId, {
          metadata: {
            agentInvokeOptions: { userContext: campaign.input.userContext },
          }
        }); 
      }
      this.logger.log(`Campaign ${campaignId} queued for retry`);
      return updatedCampaign;
    } catch (error) {
      // rollback on failure
      await this.campaignRepository.updateCampaign(campaignId, {
        status: CampaignStatus.ARCHIVED,
      });
      throw error;
    }
  }

  /**
   * Permanently delete the Campaign (including all Tasks).
   */
  public async deleteCampaign(campaignId: string, userId: string): Promise<Campaign> {
    await this.getCampaignById(campaignId, userId);

    // Remove job from the queue
    try {
      await this.queueService.removeJob(`campaign-${campaignId}`);
    } catch {
      // Ignore errors indicating the queue does not exist
    }
    return this.campaignRepository.deleteCampaignWithTasks(campaignId);
  }

}
