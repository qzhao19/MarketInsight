import { Injectable, Logger, ForbiddenException } from "@nestjs/common";
import { CampaignRepository } from "../repositories/campaign.repository";
import { QueueService } from "../../../core/job/queue.service";
import { 
  Campaign, 
  CampaignStatus,
  CreateCampaignInput,
  CreateCampaignData,
  CampaignProgress,
  CampaignWithTasks,
} from "../types/campaign.types";
import { JobStatus } from "../../../common/types/job/queue.types";

@Injectable()
export class CampaignService {
  private readonly logger = new Logger(CampaignService.name);

  constructor(
    private readonly campaignRepository: CampaignRepository,
    private readonly queueService: QueueService,
  ) {}

  // ==================== Create and launch a campaign ====================

  /**
   * Create and launch a Campaign
   * Process: Create Campaign record → Place in queue → Return (without waiting for completion)
   * 
   * No Tasks are created at this stage; Tasks are dynamically generated by the Agent during execution
   */
  public async createAndStartCampaign(input: CreateCampaignInput): Promise<Campaign> {
    this.logger.log(`Creating campaign for user: ${input.userId}`);

    // Create Campaign record (status: ACTIVE)
    const campaignData: CreateCampaignData = {
      userId: input.userId,
      name: input.name,
      description: input.description,
      status: CampaignStatus.ACTIVE,
      input: {
        userPrompt: input.userPrompt,
        userContext: input.agentInvokeOptions?.userContext,
      },
    };

    const campaign = await this.campaignRepository.createCampaign(campaignData);
    this.logger.log(`Campaign created with ID: ${campaign.id}`);

    // Put it into queue: async execution, non-blocking
    // Pass metadata to agentInvokeOptions for the Processor
    await this.queueService.addCampaignJob(campaign.id, input.userId, {
      metadata: {
        agentInvokeOptions: input.agentInvokeOptions,
      },
    });
    this.logger.log(`Campaign ${campaign.id} queued for execution`);

    // Return immediately campaign（do not wait for completion）
    return campaign;
  }

  // ==================== Query and progress ====================

  /**
   * Get the single Campaign
   */
  public async getCampaignById(
    campaignId: string,
    userId: string,
    options?: { includeTasks?: boolean, includeUser?: boolean }
  ): Promise<Campaign> {
    const campaign = await this.campaignRepository.findCampaignById(
      campaignId,
      options?.includeTasks ?? false,
      options?.includeUser ?? false,
    );

    // Only access to user"s owned Campaign
    if (campaign.userId !== userId) {
      throw new ForbiddenException("You do not have permission to access this campaign");
    }
    return campaign;
  }

  private getProgressMessage(
    jobStatus: JobStatus | null
  ): string {
    if (!jobStatus) {
      return "Campaign is pending";
    }

    switch (jobStatus.state) {
      case "waiting":
        return "Waiting in queue";
      case "active":
        return `Processing... ${jobStatus.progress}%`;
      case "completed":
        return "Completed";
      case "failed":
        return `Failed: ${jobStatus.failedReason || "Unknown error"}`;
      default:
        return "Unknown status";
    }
  }

  public async getCampaignProgress(
    campaignId: string,
    userId: string
  ): Promise<CampaignProgress> {
    // Get Campaign
    const campaign = await this.getCampaignById(campaignId, userId, { 
      includeTasks: true 
    });

    // If the database already shows it as completed or archived, return it
    if (campaign.status === CampaignStatus.ARCHIVED) {
      return {
        campaignId,
        status: campaign.status,
        message: "Campaign completed",
        taskStats: {
          total: campaign.tasks?.length || 0,
          completed: campaign.tasks?.filter(t => t.status === "COMPLETED").length || 0,
          failed: campaign.tasks?.filter(t => t.status === "FAILED").length || 0,
        }
      };
    }

    // Retrieve the status of a job in the queue
    const jobStatus = await this.queueService.getJobStatus(`campaign-${campaignId}`);

    // Build progress information
    const progress: CampaignProgress = {
      campaignId,
      status: campaign.status,
      message: this.getProgressMessage(jobStatus),
    };
    return progress;
  }

  /**
   * Retrieve completed Campaigns (including Tasks)
   */
  public async getCompletedCampaignWithTasks(
    campaignId: string,
    userId: string
  ): Promise<CampaignWithTasks> {
    const campaign = await this.getCampaignById(campaignId, userId, { 
      includeTasks: true 
    });

    // Only archived ones will have complete results
    if (campaign.status !== CampaignStatus.ARCHIVED) {
      throw new ForbiddenException("Campaign is not yet completed");
    }

    return campaign as CampaignWithTasks;
  }

  // ==================== Manager Operation ====================

  /**
   * Archive Campaign
   */
  public async archiveCampaign(campaignId: string, userId: string): Promise<Campaign> {
    await this.getCampaignById(campaignId, userId);

    // Attempt to remove it from the queue (if it is still pending).
    try {
      await this.queueService.removeJob(`campaign-${campaignId}`);
      this.logger.log(`Job removed from queue: ${campaignId}`);
    } catch {
      this.logger.warn(`Job may already be processing or completed: ${campaignId}`);
    }

    // Soft delete（remark as ARCHIVED）
    return this.campaignRepository.softDeleteCampaign(campaignId);
  }

  /**
   * Retry the failed Campaign
   */
  public async retryCampaign(campaignId: string, userId: string): Promise<Campaign> {
    const campaign = await this.getCampaignById(campaignId, userId);

    // Only status is ARCHIVED and no results can be retried
    if (campaign.status !== CampaignStatus.ARCHIVED || campaign.result !== null) {
      throw new ForbiddenException("Only failed campaigns can be retried");
    }

    // Update status first to avoid queue mismatch
    const updatedCampaign = await this.campaignRepository.updateCampaign(campaignId, {
      status: CampaignStatus.ACTIVE
    });

    try {
      const existingJob = await this.queueService
        .getJobByCampaignId(campaignId)
        .catch(() => null);      
      if (existingJob) {
        const state = await existingJob.getState();

        if (state === "failed") {
          await this.queueService.retryJob(campaignId);
        } else if (state === "completed") {
          this.logger.warn(
            `Job ${existingJob.id} completed but campaign ${campaignId} failed, creating new job`
          );
          await this.queueService.addCampaignJob(campaignId, userId, {
            metadata: {
              agentInvokeOptions: { userContext: campaign.input?.userContext },
            },
          });
        } else {
          // waiting/active/delayed status
          this.logger.warn(
            `Job ${existingJob.id} is in state: ${state}, not retrying`
          );
        }
      } else {
        await this.queueService.addCampaignJob(campaignId, userId, {
          metadata: {
            agentInvokeOptions: { userContext: campaign.input.userContext },
          }
        }); 
      }
      this.logger.log(`Campaign ${campaignId} queued for retry`);
      return updatedCampaign;
    } catch (error) {
      // rollback on failure
      await this.campaignRepository.updateCampaign(campaignId, {
        status: CampaignStatus.ARCHIVED,
      });
      throw error;
    }
  }

  /**
   * Permanently delete the Campaign (including all Tasks).
   */
  public async deleteCampaign(campaignId: string, userId: string): Promise<Campaign> {
    await this.getCampaignById(campaignId, userId);

    // Remove job from the queue
    try {
      await this.queueService.removeJob(`campaign-${campaignId}`);
    } catch {
      // Ignore errors indicating the queue does not exist
    }
    return this.campaignRepository.deleteCampaignWithTasks(campaignId);
  }

}
